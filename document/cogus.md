# Cluster Operator Generation Using Sympy

This module runs the codes generated by the **cogus** program. The *cogus* program uses the Sympy secondquant module to automatically generate Python code to evaluate various coupled-cluster methods. The codes are stored in the directory harpy/codes and are called *ccd.py*, *ccsd.py*, *ccsdt*, *ccsd_t.py*, *cc2.py*, *cc3.py*, *lccd.py* and *lccsd.py*. More details can be found in the *cogus* documentation [here](https://github.com/pwborthwick/cogus) and [here](https://github.com/pwborthwick/ToDo/blob/harpy/cogus.md). The routines are

1. **symbolicGeneratedCoupledCluster(name, fock, eri, c, e, scfData)**

   parameters - *name* is the name of the coupled-cluster method to be executed. This can be one of **ccd, ccsd, ccsdt, ccsd_t, cc2, cc3, lccd, lccsd**. *fock* is the converged Fock matrix from a Hartree-Fock calculation, *eri* are the 2-electron repulsion integrals, *c* are the converged eigenvectors, *e* are the orbital energies and *scfData* is a list containing [charge, nuclearRepulsion, number of electrons]. The program reads the *cogus* generated Python code and combines this with the code to run the cluster routines. The combined code is the executed using Pythons *exec* command. The routine returns the name of the method, cluster correction energy and either 0.0 or the perturbative correction if the method includes one. These routines are much faster than the ones in the cc module as they use einsum.

+ CCD
   + <0| e<sup>-T<sub>2</sub></sup> H<sub>N</sub> e<sup>T<sub>2</sub></sup> |0> , H<sub>N</sub> is the normal-ordered Hamiltonian.
   + <0| i<sup>+</sup>j<sup>+</sup>ab e<sup>-T<sub>2</sub></sup> H<sub>N</sub> e<sup>T<sub>2</sub></sup> |0> 

+ CCSD
   + <0| e<sup>-T<sub>1</sub>-T<sub>2</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub></sup> |0> ,
   + <0| i<sup>+</sup>a e<sup>-T<sub>1</sub>-T<sub>2</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub></sup> |0> 
   + <0| i<sup>+</sup>j<sup>+</sup>ab e<sup>-T<sub>1</sub>-T<sub>2</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub></sup> |0>

+ CCSDT
   + <0| e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0> ,
   + <0| i<sup>+</sup>a e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0> 
   + <0| i<sup>+</sup>j<sup>+</sup>ab e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0>  
   + <0| i<sup>+</sup>j<sup>+</sup>k<sup>+</sup>abc e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0> 

+ CCSD(T)
   + <0| e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0> ,
   + <0| {l<sub>1</sub>+l<sub>2</sub>} \[v,T<sub>3</sub>] |0>
   + <0| i<sup>+</sup>a e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0>
   + <0| i<sup>+</sup>j<sup>+</sup>ab e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0> 
   + <0| i<sup>+</sup>j<sup>+</sup>k<sup>+</sup>abc {e<sup>-T<sub>3</sub></sup> F<sub>N</sub> e<sup>T<sub>3</sub></sup>+e<sup>-T<sub>2</sub></sup> v<sub>N</sub> e<sup>T<sub>2</sub></sup>} |0> 

+LCCD
   + T<sub>2</sub> is restricted to only linear terms ie T<sub>2</sub><sup>(1)</sup>

+LCCSD
   + T<sub>2</sub> is restricted to only linear terms

+CC2
   + <0| e<sup>-T<sub>1</sub>-T<sub>2</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub></sup> |0> ,
   + <0| i<sup>+</sup>a e<sup>-T<sub>1</sub>-T<sub>2</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub></sup> |0> 
   + <0| i<sup>+</sup>j<sup>+</sup>ab {e<sup>-T<sub>2</sub></sup> F<sub>N</sub> e<sup>T<sub>2</sub></sup> + e<sup>-T<sub>1</sub></sup> v<sub>N</sub> e<sup>T<sub>1</sub></sup> |0>

+CC3
   + <0| e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0> ,
   + <0| i<sup>+</sup>a e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0> 
   + <0| i<sup>+</sup>j<sup>+</sup>ab e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> H<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> |0>  
   + <0| i<sup>+</sup>j<sup>+</sup>k<sup>+</sup>abc {e<sup>-T<sub>1</sub>-T<sub>2</sub>-T<sub>3</sub></sup> F<sub>N</sub> e<sup>T<sub>1</sub>+T<sub>2</sub>+T<sub>3</sub></sup> + e<sup>-T<sub>1</sub></sup> v<sub>N</sub> e<sup>T<sub>1</sub></sup>} |0> + <0| i<sup>+</sup>j<sup>+</sup>k<sup>+</sup>abc {v + \[v,T<sub>2</sub>] + \[\[v,T<sub>1</sub>],T<sub>2</sub>] + 1/2\[\[\[v,T<sub>1</sub>],T<sub>1</sub>],T<sub>2</sub>] + 1/6\[\[\[\[v,T<sub>1</sub>],T<sub>1</sub>],T<sub>1</sub>],T<sub>2</sub>]} |0>

2. **symbolicGeneratedLambda(name, fock, eri, c, e, coreH, scfData)**

   parameters - *name* is the name of the coupled-cluster method to be executed. This must be **ccsd**. *fock* is the converged Fock matrix from a Hartree-Fock calculation, *eri* are the 2-electron repulsion integrals, *c* are the converged eigenvectors, *e* are the orbital energies, *coreH* is the core Hamiltonian  and *scfData* is a list containing [charge, nuclearRepulsion, number of electrons]. The program reads the *cogus* generated Python code and combines this with the code to run the lambda routines. The combined code is the executed using Pythons *exec* command. The routine returns the name of the method, thne lambda Lagrange energy, the &Lambda;-pseudo energ and response density energy.

3. **symbolicAmplitudes(name, fock, eri, c, e, scfData, spinned = False)**

   parameters - *name* is the name of the coupled-cluster method to be executed. This must be **ccsd**. *fock* is the converged Fock matrix from a Hartree-Fock calculation, *eri* are the 2-electron repulsion integrals, *c* are the converged eigenvectors, *e* are the orbital energies and *scfData* is a list containing [charge, nuclearRepulsion, number of electrons]. The parameter *spinned* allows already spin MO versions of fock, eri and e to be supplied to the routine. *c* can be either spin or unspinned if *spinned* is True as it is not used. The program reads the *cogus* generated Python code and combines this with the code to run the cluster routines. The combined code is the executed using Pythons *exec* command. The routine returns the name of the method and the singles, doubles and triples amplitude (where appropriate). The *name* can be ccd, ccsd, ccsdt or ccsd_t. If *spinned* is True then spin MO versions of Fock, eri and orbital energies must be supplied.
   